      subroutine vbdass(horiz, vert, itrnsp, bdy)
c routine written by Richard James for 3-D Poisson solver
      integer bdy( 6 ), horiz( 6 ), itrnsp( 3 ), vert( 257 )
c
c     purpose
c
c        to assemble the various contributions to the boundary
c        potential generated by vbdpot(xf) into a single sine-sine
c        transform for each boundary plane
c
c     parameters
c
c     horiz   -  an integer array of 6 elements, pointing on
c                entry to 6 transforms of sums and differences of
c                potentials on the horizontal boundaries.  these are
c                held in the usual order (cc+, cc-, cs+, cs-, sc+, sc-)
c
c     vert    -  an integer array with one element per
c                horizontal plane.  each element points to a vector
c                with length = 6*(sum of horizontal dimensions)
c                holding on entry parts of the various transforms of
c                contributions on the vertical boundaries.
c
c     itrnsp  -  an integer array of 3 elements, pointing
c                to the vectors holding transposition indices for
c                boundary planes.
c
c     bdy     -  an integer array of 6 elements, pointing to
c                vectors associated with the 6 boundary planes.  each
c                vector contains the sine-sine transform of the
c                boundary charges on entry.  it contains the same
c                transform of the final boundary potential on exit.
c
c     notes:
c
c     1)   the mesh is assumed to have experienced two rotations
c          during the fourier transformation stage preceding this
c          routine, and so has  n3  planes, each containing  n1  rows
c          of  n2  elements.
c
c     2)   the order adopted for sets of transforms (segmented or
c          otherwise) is cc+, cc-, cs+, cs-, sc+, sc-.
c
c     3)   for efficiency reasons, transposition indices are
c          pre-calculated by vbdpot(xf).
c
      include 'rjinclude.h'
c
c local variables
      integer i, idir, is, iseg, isign, istck0, isv, is1, is2, j,
     1        llen, lenrem, lenrow, lenseg, len1, len2, lseg, l1,
     2        l12, l13, l2, l23, l3, nr, nrem, nrows, nsegs, num
      real u, x
c
c      integer bdy(6), horiz(6), vert(257), itrnsp(3),
      integer cc(2), cs(2),
     1  sc(2), ccv(2, 2:3, 20), csv(2, 2:3, 20), scv(2, 2:3, 20),
     2  indxa(2:3)
      logical rem, plus
      integer l(3), ll(3)
c
c     set up array dimensions and check working area size
c
      l1 = n3
      l2 = n1
      l3 = n2
      l23 = l2*l3
      l13 = l1*l3
      l12 = l1*l2
      l(1) = l1
      l(2) = l2
      l(3) = l3
      ll(1) = l23
      ll(2) = l13
      ll(3) = l12
      i = 2*max0(l23, l13, l12)
      if(i.gt.lnwork) then
        write( s2, 200 )i, lnwork
 200    format( 'Insufficient space in /work/ for vbdass(xh)' /
     1          ' space required =', i10, 5x, 'space available =', i10 )
        call crash( 'vbdass', 'xh 1')
      end if
c
c     check length of vectorisation work area.
c
      if(i.gt.lnvect) then
        write( s2, 201 )i, lnvect
 201    format( '/vect/ too small in vbdass(xh)'/
     1          ' space required =', i10, ' space available =', i10 )
        call crash( 'vbdass', 'xh 2')
        stop
      end if
c
c     calculate number of segments required for vertical boundaries
c
      lenrow = 6*(l2 + l3)
      nrows = min0(lnwork/lenrow, l1)
      nsegs = l1/nrows
      nrem = l1 - nrows*nsegs
      rem = nrem.ne.0
      if((nsegs.gt.20).or.(rem.and.(nsegs.eq.20))) then
        write( s2, 202 )nsegs, lnwork, lenrow, nrem
 202    format( 'Too many vertical segments in vbdtab(xg)' /
     1          ' nsegs = ', i10, 5x,
     2          'lnwork = ', i10, 5x, 'lenrow =', i10, 5x,
     3          'nrem =', i10 )
        call crash( 'vbdass', 'xh 3')
      end if
c
c     set local pointers for results.
c
      cc(1) = horiz(1)
      cc(2) = horiz(2)
      cs(1) = horiz(3)
      cs(2) = horiz(4)
      sc(1) = horiz(5)
      sc(2) = horiz(6)
c
c     cycle over pointers required for vertical boundaries.
c
      i = istack
      len1 = nrows*l3
      len2 = nrem*l3
      do 3 idir = 2, 3
      do 2 isign = 1, 2
      do 1 iseg = 1, nsegs
      ccv(isign, idir, iseg) = i
      csv(isign, idir, iseg) = i + len1
      scv(isign, idir, iseg) = i + 2*len1
 1    i = i + 3*len1
      if(rem) then
        ccv(isign, idir, nsegs + 1) = i
        csv(isign, idir, nsegs + 1) = i + len2
        scv(isign, idir, nsegs + 1) = i + 2*len2
        i = i + 3*len2
      end if
 2    continue
      len1 = nrows*l2
 3    len2 = nrem*l2
c
c     pointers to gather index vectors.
c
      indxa(2) = i
      i        = i + nrows*l3
      if(l2.eq.l3) then
        indxa(3) = indxa(2)
      else
        indxa(3) = i
        i        = i + nrows*l2
      end if
c
c     advance stack pointer and check for stack overflow.
c
      istck0 = istack
      istack = i
      if(istack.gt.maxstk) then
        maxstk = istack
        mxstid = 'vbdass'
      end if
      if(istack.gt.lstack) then
        write( s2, 204 )istck0, istack, lstack
 204    format( 'Stack overflow in vbdass(xh)' /
     1          ' old pointer =', i10, ' new pointer =', i10,
     2          ' limit =', i10 )
        call crash( 'vbdass', 'xh 4')
        stop
      end if
c
c     construct gather index vectors
c
      do 4 idir = 2, 3
      if((l2.eq.l3).and.(idir.eq.3)) go to 4
      llen = l(5 - idir)
      num = nrows*llen
      u = 1.0/float(llen)
      do 20 i = 1, num
20    jstack(indxa(idir) + i) = i
     1                       + (lenrow - llen)*int(u*(float(i) - 0.5))
 4    continue
c
c     repack information for vertical boundaries
c
c     cycle over segments
c
      lseg = nsegs
      if(rem) lseg = nsegs + 1
      isv = 0
      do 6 iseg = 1, lseg
c
c     recover rows in segment
c
      is = 0
      nr = nrows
      if(iseg.gt.nsegs) nr = nrem
      do 5 j = 1, nr
      isv = isv + 1
      do 21 i = 1, lenrow
21    work(is + i) = wstack(vert(isv) + i)
 5    is = is + lenrow
c
c     extract transforms and send to segment storage
c
      is = 0
      do 6 idir = 2, 3
      llen = l(5 - idir)
      if(iseg.le.nsegs) then
        num = nrows*llen
      else
        num = nrem*llen
      end if
      do 22 i = 1, num
22    ivect(i) = jstack(indxa(idir) + i)
      do 23 i = 1, num
23    wstack(ccv(1, idir, iseg) + i) = work(is + ivect(i))
      is = is + llen
      do 24 i = 1, num
24    wstack(ccv(2, idir, iseg) + i) = work(is + ivect(i))
      is = is + llen
      do 25 i = 1, num
25    wstack(csv(1, idir, iseg) + i) = work(is + ivect(i))
      is = is + llen
      do 26 i = 1, num
26    wstack(csv(2, idir, iseg) + i) = work(is + ivect(i))
      is = is + llen
      do 27 i = 1, num
27    wstack(scv(1, idir, iseg) + i) = work(is + ivect(i))
      is = is + llen
      do 28 i = 1, num
28    wstack(scv(2, idir, iseg) + i) = work(is + ivect(i))
 6    is = is + llen
c
c     cycle over pairs of parallel boundaries
c
      len1 = l2
      len2 = l3
      do 10 idir = 1, 3
      if(idir.eq.3) len2 = l2
      llen = len1*len2
c
c     cycle over signs
c
      do 9 isign = 1, 2
      plus = isign.eq.1
c
c     get transforms into working area
c
      if(idir.eq.1) then
        do 29 i = 1, llen
29      work(i)       = wstack(cc(isign) + i)
        do 30 i = 1, llen
30      work(llen + i) = wstack(sc(isign) + i)
      else
c
c       cycle over segments
c
        is1 = 0
        is2 = llen
        lenseg = nrows*len2
        lenrem = nrem*len2
        do 7 iseg = 1, nsegs
        do 31 i = 1, lenseg
31      work(is1 + i) = wstack(ccv(isign, idir, iseg) + i)
        do 32 i = 1, lenseg
32      work(is2 + i) = wstack(scv(isign, idir, iseg) + i)
        is1 = is1 + lenseg
 7      is2 = is2 + lenseg
        if(rem) then
          do 33 i = 1, lenrem
33        work(is1 + i) = wstack(ccv(isign, idir, nsegs + 1) + i)
          do 34 i = 1, lenrem
34        work(is2 + i) = wstack(scv(isign, idir, nsegs + 1) + i)
        end if
      end if
c
c     convert cc transform into an sc transform and combine the two.
c     note that we must compensate for the offset in the vertical
c     sc transforms.
c
      call vfthil(len1, len2, work, .false.)
      j = llen + len2
      if(idir.gt.1) j = j + len2
      do 35 i = 1, llen - 2*len2
35    vect(i) = work(len2 + i) + work(j + i)
      do 36 i = 1, llen - 2*len2
36    work(len2 + i) = vect(i)
c
c     convert into an ss transform
c
      do 37 i = 1, llen
37    vect(i) = work(jstack(itrnsp(idir) + i))
      do 38 i = 1, llen
38    work(llen + i) = vect(i)
      call vfthil(len2, len1, work(llen + 1), .false.)
      do 39 i = 1, llen
39    vect(jstack(itrnsp(idir) + i)) = work(llen + i)
      do 40 i = 1, llen
40    work(i) = vect(i)
c
c     pick up cs transform
c
      if(idir.eq.1) then
        do 41 i = 1, l23
41      work(llen + i) = wstack(cs(isign) + i)
      else
c
c       cycle over segments
c
        is1 = llen
        do 8 iseg = 1, nsegs
        do 42 i = 1, lenseg
42      work(is1 + i) = wstack(csv(isign, idir, iseg) + i)
 8      is1 = is1 + lenseg
        if(rem) then
          do 43 i = 1, lenrem
43        work(is1 + i) = wstack(csv(isign, idir, nsegs + 1) + i)
        end if
      end if
c
c     convert into ss transform
c
      call vfthil(len1, len2, work(llen + 1), .false.)
c
c     set unwanted border contributions to zero and then merge.
c
      do 44 i = llen + 1, 2*llen, len2
44    work(i) = 0.0
      do 45 i = llen + len2, 2*llen, len2
45    work(i) = 0.0
      do 46 i = 1, llen
46    vect(i) = work(i) + work(llen + i)
c
c     clear borders for existing ss transform and merge in.
c
      j = idir + idir + isign - 2
      do 47 i = 1, llen, len2
47    wstack(bdy(j) + i) = 0.0
      do 48 i = len2, llen, len2
48    wstack(bdy(j) + i) = 0.0
      do 49 i = 1, len2
49    wstack(bdy(j) + i) = 0.0
      do 50 i = llen - len2 + 1, llen
50    wstack(bdy(j) + i) = 0.0
      do 51 i = 1, llen
51    wstack(bdy(j) + i) = wstack(bdy(j) + i) + vect(i)
c
c     if this is the second of the pair, add, subtract and scale
c     for final result.
c
      if(.not.plus) then
        x = 0.25*float((len1 - 1)*(len2 - 1))
        do 52 i = 1, llen
52      vect(i)       = wstack(bdy(j - 1) + i) - wstack(bdy(j) + i)
        do 53 i = 1, llen
53      vect(llen + i) = wstack(bdy(j - 1) + i) + wstack(bdy(j) + i)
        do 54 i = 1, llen
54      wstack(bdy(j - 1) + i) = x*vect(llen + i)
        do 55 i = 1, llen
55      wstack(bdy(j) + i)     = x*vect(i)
      end if
c
c     end of loop over signs
c
 9    continue
c
c     end of loop over directions
c
10    len1 = l1
c
c     reset stack pointer.
c
      istack = istck0
c
c     finish
c
      return
      end
