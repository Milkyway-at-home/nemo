%% This file is to be included by latex in nemo.tex
%
%  Chapter: User Interface
\myfile{iface.inc}
\mylabel{c:iface}

   A NEMO program is invoked just as any other application program under
the operating system.  Of course you must have modified your shell
%\footnote{Male users assumed, but certainly not preclusively.}
environment (see Appendix~\ref{a:setup} on how to modify your account). 

   In the first section the keyword interface is explained. 
Subsequently, we will explain some of the more advanced concepts of this
user interface, which can be skipped on first reading without loosing
any essentials.  Some of these advanced features may not even be
available in your local implementation.  The last section discusses the
overall documentation system in NEMO, and how to get
different types of help.  Appendix
\ref{a:iface} serves as a reference guide to the various user
interfaces. 

\section{Keywords}

\subsection{Program Keywords}

The most basic user interface is formed by the command line interface.
Every NEMO program accepts input through a list
of so-called 
{\bf program keywords}\index{keywords, program}\index{program keywords},
constructed as '{\it keyword=value}' 
string pairs on the commandline. We shall go through
a few examples and point out a few noteworthy 
things as we go along. The first
example\footnote{from here on the {\tt \%} will 
denote the prompt of the operating system, anything after that on that line
you type - subsequent lines without a prompt are output from the program.
The number preceding is an identification number.}:

\index{hackcode1(1)}
\small
\begin{verbatim}
    1% hackcode1 out=r001.dat

    Hack code: test data
 
       nbody        freq         eps         tol
         128       32.00      0.0500      1.0000

        options: mass,phase

        tnow       T+U       T/U     nttot     nbavg     ncavg   cputime
       0.000   -0.2943   -0.4940      4363        15        18      0.01

                cm pos   -0.0000   -0.0000   -0.0000
                cm vel    0.0000    0.0000   -0.0000

        particle data written

        tnow       T+U       T/U     nttot     nbavg     ncavg   cputime
       0.031   -0.2940   -0.4938      4397        15        18      0.01

                cm pos    0.0000    0.0000   -0.0000
                cm vel    0.0001    0.0001   -0.0000

        tnow       T+U       T/U     nttot     nbavg     ncavg   cputime
       0.062   -0.2938   -0.4941      4523        16        18      0.02

                cm pos    0.0000    0.0000   -0.0000
                cm vel    0.0002    0.0002    0.0000

        ...
\end{verbatim}
\normalsize
will integrate an (automatically generated) stellar system with 128 particles
for 64 time steps.
If your CPU is very slow, abort the program with {\tt <control>-C} and
re-run it with fewer particles:

\small\begin{verbatim}
   ....
   <Control>-C 
   REVIEW called, enter your command:
   REVIEW|hackcode1> quit
   2% hackcode1 out=r001.dat nbody=32 > r001.log
   ### Fatal error [hackcode1] stropen in hackcode1: file "r001.dat" already exists
   3% rm r001.dat
   4% hackcode1 out=r001.dat nbody=32 > r001.log

\end{verbatim}\normalsize

This example already shows a few peculiarities of the NEMO user interface.
First of all, an interrupt might\index{interrupt, a NEMO program}
have thrown you into the REVIEW\index{REVIEW} section: the
{\tt quit} command is needed to get you back to the parent shell. This
REVIEW section may not have been compiled into your user interface,
in which case not to worry. The second peculiarity is shown by the
line starting with ``{\tt \#\#\#}''. It is generated by the
fatal error\index{error, fatal}
routine, which immediately\footnote{There are ways around this,
see the {\tt error=} keyword described later in this section}
aborts the program with a message to the terminal, even
if the normal output was 
diverted\footnote{Technically, it was written to the standard error
output channel, commonly called {\it stderr}\index{stderr}
in UNIX} to a log-file, as in this example.
The error shows that in general NEMO programs do not allow 
files to be overwritten, and hence the {\tt r001.dat} file,
which was already (partially) created in the previous run, must be
deleted before {\tt hackcode1} can be re-run with the same
keywords. The datafile, {\tt r001.dat}, is in a peculiar binary
format, which we shall discuss in the next chapter.

Now, plotting the first snapshot of the run can be done as follows:
\index{snapplot}
\begin{verbatim}
    5% snapplot in=r001.dat times=0
\end{verbatim}

It plots an X-Y projection of the initial conditions from the
data file {\tt r001.dat} at time 0.0.  Your display will hopefully look
something like the one displayed in Figure~\ref{f:init}.

\begin{figure}[t]
 \ifdoplot
   % \PSinsert{encounter1.ps}{7.5}{7.5}{0.5}{0.5}{1}{0}
 \else
    \vspace{1.0in}
    \begin{center}
      {\it To generate this plot run ....}
    \end{center}
    \vspace{1.0in}
 \fi
 \caption[Hackcode1: default initial conditions]{Initial conditions for 
hackcode1}
 \mylabel{f:init}
\end{figure}

There are many more keywords to this particular program, but they all have
sensible default values and don't have to be supplied.
However, an invocation like

\begin{verbatim}
    6% snapplot
\end{verbatim}

will generally result in an error message, and shows
you the minimum list of 
keywords which need a value. {\tt snapplot} will then output
something like

\begin{verbatim}
    Insufficient parameters, try keyword 'help=', otherwise:
    Usage: snapplot in=??? ...
    plot particle positions from a snapshot file
\end{verbatim}

which already suggests that issuing the {\tt help=} keyword
will list all possible keywords and their associated defaults:

\begin{verbatim}
    7% snapplot help=
\end{verbatim}

results in something like:\footnote{Your local VERSION will 
probably look a little different.}

\begin{verbatim}
    snapplot in=??? times=all xvar=x xlabel= xrange=-2.0:2.0 
        yvar=y ylabel= yrange=-2.0:2.0 visib=1 psize=0 
        fill_circle=t frame= VERSION=1.3f
\end{verbatim}

As you see, {\tt snapplot} happens to be a program
with quite an extensive parameter list.
Also note that {\tt 'help'} itself is not listed in the above list of program
keywords because it is a {\bf system keyword}\index{keywords, 
system}\index{system keywords} (more on these later).

There are a few ``short-cut''
in this user interface worth mentioning 
at this\index{shortcut, [key=]value}
stage.  First of all, keywords don't have to be specified 
by name, as long as you specify values in the correct
order, they will be associated by the appropriate keyword.
The order of program keywords can be seen with
the keyword {\tt help=}.
\index{keywords, order of} The moment you deviate from
this order, or leave gaps, all 
values must be accompanied by their keywords, {\it i.e.} in
the example

\begin{verbatim}
    8% snapplot r001.dat 0,2 xrange=-5:5 yrange=-5:5 "visib=i<10"
\end{verbatim}

the second argument {\tt 0,2} binds to {\tt times=0,2}; but if a value
{\tt "i<10"} for {\tt visib} (the keyword immediately following
{\tt yrange=}) would be needed, the full
{\tt "visib=i<10"} would have  to be supplied to the command line,
anywhere after the first {\tt 0,2} where the keywords are explicitly
named. Also note the use of quotes\index{quotes}\index{meta, shell
characters} around the {\tt visib=} keyword, to prevent the UNIX shell
from interpreting the {\tt <} sign for I/O redirection. In this 
particular case double as well as single quotes would have worked.

There are two other user interface short-cuts worth knowing about.
. The {\tt macro-include} or
{\tt keyword include}\index{include, keyword include}{\index{keyword include}
allows you to prefix an existing
filename with the \verb+@+-symbol, which causes the contents
of that file to become the keyword value. In UNIX the following two
are nearly equivalent (treatment of multiple lines may cause
differences in the subsequent parsing of the keyword value):

\begin{verbatim}
    9% program a=@keyfile
   10% program a="`cat keyfile`"
\end{verbatim}

Also useful is the {\tt reference include}\index{include, reference
include} \index{reference include}, which uses the \verb+$+-symbol to
prefix another program keyword, and causes the contents of that keyword
to be included in-place.  An obvious warning is in place: you cannot use
recursion here.  So, for example,

\begin{verbatim}
   11% program a=$b b=$a          <---- illegal !!!
\end{verbatim}

will probably cause the user interface to run out of memory or return
something meaningless. Also, since
the \verb+$+-symbol has special meaning to the UNIX shell, it has to be
passed in a special way, for example

\begin{verbatim}
   12% program a=5 b=3+\$a
   13% program a=5 'b=3+$a'
\end{verbatim}

are both equivalent.

% A third interesting shortcut is something new and introduced in version 3.2,
% which allows keyword references using the \% symbol to cut accross programs.

\subsection{System Keywords}

As just mentioned before, there are a fixed set of keywords to every NEMO
program which are the ``hidden'' {\bf system keywords}; \index{keywords,
system} their values are defined automatically for the user by the
user-interface routines from environment\index{\$, environment
variables} variables \index{environment variables} or, when absent,
sensible preset defaults.  They handle certain global (system) features
and are not listed through the '{\tt help=}' keyword.  Of course their
values can always be overridden by supplying it as a system parameter on
the command line.  In summary, the system keywords are:

\begin{itemize}
\item The {\tt help=} keyword itself, gives you a list of all available
keywords to this specific program but can also aid you in command
completion and/or explanation of keywords.
\index{help=, system keyword}

\item The {\tt debug=} keyword lets you upgrade the debug output level.  This
may be useful to check proper execution when a program seemingly takes
too long to complete, or to trace weird errors.  Output is to
{\it stderr} though.\index{stderr} Default level is 0.
\index{debug=, system keyword}

\item The {\tt yapp=} keyword lets you (re)define the graphics output device.
\index{yapp=, system keyword} Usually no default.

\item The {\tt error=} keyword allows you to override a specified number
of fatal error calls. Not adviced really, but it's there to use in case
you really know what you're doing\footnote{bypassing existence of an
output file is a very common use}
\index{error=, system keyword} Default is 0.
%
%\item The {\tt host=} keyword allows you to run the program at a different
%host machine. Handy in a distributed network environment. 
%\index{host=, system keyword} Not useful anymore.

\item The {\tt review=} keyword jumps the user into the REVIEW section before
the actual execution of the NEMO program for a last review of the parameters
before execution starts. (see also next section).

\end{itemize}

For a more detailed description of the system keywords and all their options
see Appendix~\ref{a:iface}.  The actual degree of implementation of the system
keywords can be site dependent.  Use the {\tt help=\\?} argument to any
NEMO program to glean into the options the user interface was compiled with.
Recent updates can also be found in NEMO's
online manual pages, {\it getparam(3NEMO)}. \index{getparam}

% 
% Whenever, in this manual, a program or subroutine is printed in 
% {\it italics} with a number between brackets, it means that more 
% online information can be found using the UNIX {\tt man} 
% command\footnote{See comments on the MANPATH environment variable if
% this command doesn't seem to work for you}
% in the case of {\it getparam(3NEMO)}:
% \index{manual, online}
% \begin{verbatim}
%     % man 3 getparam
% \end{verbatim}
% The {\tt "3"} is optional if there is no information under the same
% name in another lower numbered section of the manual pages. NEMO uses sections
% 1,3,5 and 8\index{man, manual pages}, in the usual convention
% for {\it programs}, {\it library functions}, {\it file formats}
% and {\it maintenance}.

\section{Interrupt to the REVIEW section}

% \footnote[*]{This section describes
% advanced features of the User Interface that are not always implemented;
% it should be skipped on first reading}
NEMO programs are generally 
not interactive, they are of the so-called
``{\it load-and-go}'' type, {\it i.e.} at startup all necessary parameters are
supplied either through the commandline, or, as will be described later,
a keyword file or even a combination thereof.  The actual program is then
started until it's all done.  There is no feedback possible to the user.  
This is particularly convenient when combining programs into a script
or batch type environments.

There are of course a few exceptions.  Certain graphics interfaces
require the user to push a button on the keyboard or click the mouse to
advance to a next frame or something like that; a few very old NEMO
programs may still get their input through user defined routines
(they will become obsolete).

Depending on how the user interface on your system has been compiled,
NEMO programs can be interrupted\footnote{UNIX programs can be
interrupted with (control-backslash)} to go into the REVIEW
\index{REVIEW} section during, or even optionally at the start of the
execution of the program.  The program pauses here for user interaction. 
\index{interrupting a program}

The {\tt REVIEW>>} prompt appears and the user can interact with the
program and reset keywords.  The program can also be continued or
gracefully aborted, and other programs can be run in the mean time.  In
Appendix~\ref{a:review} an overview of all the commands and their
options are given in more detail. 

It should be remarked though that the program must be written in a
certain way that resetting the value of the keyword also affects the
actual flow of the program.  Although this is always true for the system
\index{keywords, system} keywords ({\tt help, yapp, debug} etc.), it is
not guaranteed\footnote{In fact, this is hardly anywhere the case} for
the program defined keywords (the ones you see when the {\tt help=}
keyword is used).  The documentation should explain how to handle such
situations, however in most current situations modifying a program
keyword will not affect the flow of the program. A good example
would be a program that iterates, and is given a new tolerance
criterion or new initial conditions.

The REVIEW section is mostly useful to interrupt a quiet program that
seems to take to long, and \index{debug=, system keyword} increase the
{\tt debug} level. 

\section{Advanced User Interfaces}

The command-line interface, as we described it above, makes it
relatively straightforward to ``plug'' in any other front-end as a new
user interface with possibly a very different look-and-feel.
In fact, the command-line interface is the most primitive
front-end that we can think of: most host shell interpreters can be
used to perform various short-cuts in executing programs.  Modern 
interactive UNIX
shells like {\tt tcsh} \index{tcsh, shell} and {\tt bash}\index{bash,
shell} can be used very efficiently in this mode. 
In batch mode shell scripts, if used properly, can provide a very
powerful method of running complex simulations.
Other plug-compatible
interfaces that are available are {\tt mirtool}\index{mirtool} and {\tt
miriad}\index{miriad}, described in more detail in
Appendix~\ref{s:mirtool} and \ref{s:miriad} There was also a
Khoros\index{Khoros} (cantata, under khoros V1)
interface\footnote{See also {\tt http://www.khoral.com} for their new release}
available, but this product is not open source anymore.
Lastly, lets not forget scripting languages like python, perl and ruby. 
Although the class UNIX (c)sh shell is very WYSIWYG, with a modest amount
of investment the programmability of higher level scripts can give you
a very powerful programming environment.\footnote{It is envisioned
NEMO will - perhaps via a SWIG, or-like, environment - support such
an environment}

\section{Help}

The HELP system in NEMO is manyfold.

\begin{itemize}

\item Inline help, using the {\tt help=} system keyword,
    is available for each program. Since this is compiled
    into the program, you can copy a program to another
    system, without all the NEMO ssystem support, and still
    have a little bit of help.

\item manual pages for programs, functions, and file
    formats, all in good old UNIX tradition. All these
    files live in {\tt \$NEMO/man} and below.
    Several interfaces to the manual pages
    are now available:

    \begin{itemize}
    \item good old UNIX {\it man(1)}, but make sure the\index{man}
        {\bf MANPATH} environment variable includes the
        {\tt \$NEMO/man} directory. The {\tt manlaser} script
	can print out the manual pages in a decent form.
    \item The X-windows utility {\it xman(1)} provides a\index{xman}
        point-and-click interface, and also has a decent
        {\it whatis} interface. No hypertext though, but
        very fast since it directly interprets the 
        {\it cat} files.\index{man, xman}
    \item The Tcl/Tk X-windows utility {\it tkman} formats\index{tkman}
        manual pages on-the-fly and allows hypertextual
        moving around. 
 and has lots of good
        options, such as dynamic manipulation of the
        {\bf MANPATH} elements, a history and bookmark
        mechanism etc.\index{man, tkman}
    \item Under GNOME the {\tt gman} formats\index{gman} tool
	has nice browsing capabilities.\index{man, gman}
    \item The html formatted\index{html, manual pages}
        manual pages. Has limited form of hypertext,
        but contains the links to general UNIX manual
        pages, if properly addressed.\index{man, html format}
        Since installation
        is a bit tricky\footnote{really: not documented},
        the home base 
(\htmladdnormallink{\tt http://www.astro.umd.edu/nemo/}
{{\tt http://www.astro.umd.edu/nemo/}} is your
        best bet to start surfing).
    \end{itemize}

\item This manual, the {\it The NEMO User and Programmers Guide},
    contains information on a wide level, aimed at beginners
    as well as advanced users. The manual is also available in html.
    

\end{itemize}


