<BODY><PRE>
<B>VOGL MANUAL</B>
<hr>
<B><a href="#NAME">NAME</B></a>
</hr>
<a href="#DESC"><B>DESCRIPTION</B></a>
</HR>
<B>INDEX</B>
<UL>
   <LI><B><a href="#include">Include files</a>.</B>
   <LI><B>A brief <a href="#summary">summary</a> of the VOGL subroutines.</B>
   <LI><B>Using X <a href="#toolkits">toolkits</a> and Sunview</B>
   <LI><B><a href="#devroutines">Device routines</a>.</B>
   <LI><B>Routines for controling <a href="#flushing">flushing or syncronisation</a> of the display.</B>
   <LI><B>Routines For <a href="#setup">Setting Up Windows</a>.</B>
   <LI><B><a href="#general">General Routines</a>.</B>
   <LI><B>The <a href="#queue">Device Queue and Valuator</a> Routines.</B>
   <LI><B><a href="#vproutines">Viewport Routines</a>.</B>
   <LI><B><a href="#stack">Attribute Stack Routines</a>.</B>
   <LI><B><a href="#projection">Projection Routines</a>.</B>
   <LI><B><a href="#matrix">Matrix Stack Routines</a>.</B>
   <LI><B><a href="#vpnrout">Viewpoint Routines</a>.</B>
   <LI><B><a href="#movrout">Move Routines</a>.</B>
   <LI><B><a href="#Line">Line routines</a>.</B>
   <LI><B><a href="#Drawing">Drawing Routines</a>.</B>
   <LI><B><a href="#Vertex">Vertex calls</a>.</B>
   <LI><B><a href="#Arcs">Arcs and Circles</a>.</B>
   <LI><B><a href="#Curve">Curve Routines</a>.</B>
   <LI><B><a href="#Rect">Rectangles and General Polygon Routines</a>.</B>
   <LI><B><a href="#Text">Text routines</a>.</B>
   <LI><B><a href="#Transf">Transformations Routines</a>.</B>
   <LI><B><a href="#Patch">Patch Routines</a>.</B>
   <LI><B><a href="#Point">Point Routines</a>.</B>
   <LI><B><a href="#Obj">Object Routines</a>.</B>
   <LI><B><a href="#Buff">Double Buffering</a>.</B>
   <LI><B><a href="#Pos">Position Routines</a>.</B>
</UL>
<B><a href="#Bugs">BUGS</a></B>
<hr>
<B>Routine Index</B><P>
</hr>
<hr>
<UL>
 <LI><I><a href="#voxtwindow">vo_xt_window</a>(display, xwin, width, height)</I>
 <LI><I><a href="#voxtwinsize">vo_xt_win_size</a>(width, height)</I>
 <LI><I><a href="#vosunviewcanvas">vo_sunview_canvas</a>(canvas, width, height)</I>
 <LI><I><a href="#vosunviewcanvassize">vo_sunview_canvas_size</a>(width, height)</I>
 <LI><I><a href="#vinit">vinit</a>(device)</I>
 <LI><I><a href="#ginit">ginit</a>()</I>
 <LI><I><a href="#winopen">winopen</a>(title)</I>
 <LI><I><a href="#gexit">gexit</a>()</I>
 <LI><I><a href="#voutput">voutput</a>(path)</I>
 <LI><I><a href="#newdev">vnewdev</a>(device)</I>
 <LI><I><a href="#getplanes">getplanes</a>()  </I>
 <LI><I><a href="#vsetflush">vsetflush</a>(yesno)</I>
 <LI><I><a href="#vflush">vflush()</a></I>
 <LI><I><a href="#prefposition">prefposition</a>(x1, y1, x2, y2)</I>
 <LI><I><a href="#prefsize">prefsize</a>(width, height)</I>
 <LI><I><a href="#reshapeviewport">reshapeviewport</a></I>
 <LI><I><a href="#clear">clear</a>()</I>
 <LI><I><a href="#color">color</a>(col)</I>
 <LI><I><a href="#colorf">colorf</a>(col)</I>
 <LI><I><a href="#mapcolor">mapcolor</a>(indx, red, green, blue)</I>
 <LI><I><a href="#defbasis">defbasis</a>(id, mat)</I>
 <LI><I><a href="#polymode">polymode</a>(mode)</I>
 <LI><I><a href="#qdevice">qdevice</a>(dev)</I>
 <LI><I><a href="#unqdevice">unqdevice</a>(dev)</I>
 <LI><I><a href="#qread">qread</a>(data)</I>
 <LI><I><a href="#isqueued">isqueued</a>(dev)</I>
 <LI><I><a href="#qtest">qtest</a>()</I>
 <LI><I><a href="#qreset">qreset</a>()</I>
 <LI><I><a href="#getbutton">getbutton</a>(dev)</I>
 <LI><I><a href="#getvaluator">getvaluator</a>(dev)</I>
 <LI><I><a href="#viewport">viewport</a>(left, right, bottom, top)</I>
 <LI><I><a href="#pushviewport">pushviewport</a>()</I>
 <LI><I><a href="#popviewport">popviewport</a>()</I>
 <LI><I><a href="#getviewport">getviewport</a>(left, right, bottom, top)</I>
 <LI><I><a href="#pushattributes">pushattributes</a>()</I>
 <LI><I><a href="#popattributes">popattributes</a>()</I>
 <LI><I><a href="#ortho">ortho</a>(left, right, bottom, top, near, far)</I>
 <LI><I><a href="#ortho2">ortho2</a>(left, right, bottom, top)</I>
 <LI><I><a href="#perspective">perspective</a>(fov, aspect, near, far)</I>
 <LI><I><a href="#window">window</a>(left, right, bot, top, near, far)</I>
 <LI><I><a href="#pushmatrix">pushmatrix</a>()</I>
 <LI><I><a href="#popmatrix">popmatrix</a>()</I>
 <LI><I><a href="#polarview">polarview</a>(dist, azim, inc, twist)</I>
 <LI><I><a href="#lookat">lookat</a>(vx, vy, vz, px, py, pz, twist)</I>
 <LI><I><a href="#move">move</a>(x, y, z)</I>
 <LI><I><a href="#rmv">rmv</a>(deltax, deltay, deltaz)</I>
 <LI><I><a href="#move2">move2</a>(x, y)</I>
 <LI><I><a href="#rmv2">rmv2</a>(deltax, deltay)</I>
 <LI><I><a href="#deflinestyle">deflinestyle</a>(n, style)</I>
 <LI><I><a href="#setlinestyle">setlinestyle</a>(n)</I>
 <LI><I><a href="#linewidth">linewidth</a>(n)</I>
 <LI><I><a href="#draw">draw</a>(x, y, z)</I>
 <LI><I><a href="#rdr">rdr</a>(deltax, deltay, deltaz)</I>
 <LI><I><a href="#draw2">draw2</a>(x, y)</I>
 <LI><I><a href="#rdr2">rdr2</a>(deltax, deltay)</I>
 <LI><I><a href="#v4d">v4d</a>(v) </I>
 <LI><I><a href="#v4f">v4f</a>(v)  </I>
 <LI><I><a href="#v4i">v4i</a>(v) </I>
 <LI><I><a href="#v4s">v4s</a>(v)</I>
 <LI><I><a href="#circleprecision">circleprecision</a>(nsegs)</I>
 <LI><I><a href="#arc">arc</a>(x, y, radius, startang, endang)</I>
 <LI><I><a href="#arcf">arcf</a>(x, y, radius, startang, endang)</I>
 <LI><I><a href="#circ">circ</a>(x, y, radius)</I>
 <LI><I><a href="#circf">circf</a>(x, y, radius)</I>
 <LI><I><a href="#curvebasis">curvebasis</a>(id)</I>
 <LI><I><a href="#curveprecision">curveprecision</a>(nsegs)</I>
 <LI><I><a href="#rcrv">rcrv</a>(geom)</I>
 <LI><I><a href="#rcrvn">rcrvn</a>(n, geom)</I>
 <LI><I><a href="#crv">crv</a>(geom)</I>
 <LI><I><a href="#crvn">crvn</a>(n, geom)</I>
 <LI><I><a href="#curveit">curveit</a>(n)</I>
 <LI><I><a href="#rect">rect</a>(x1, y1, x2, y2)</I>
 <LI><I><a href="#rectf">rectf</a>(x1, y1, x2, y2)</I>
 <LI><I><a href="#poly2">poly2</a>(n, points)</I>
 <LI><I><a href="#polf2">polf2</a>(n, points)</I>
 <LI><I><a href="#poly">poly</a>(n, points)</I>
 <LI><I><a href="#polf">polf</a>(n, points)</I>
 <LI><I><a href="#backface">backface</a>(onoff)</I>
 <LI><I><a href="#frontface">frontface</a>(onoff)</I>
 <LI><I><a href="#font">font</a>(fontid)</I>
 <LI><I><a href="#cmov">cmov</a>(x, y, z)</I>
 <LI><I><a href="#cmov2">cmov2</a>(x, y)</I>
 <LI><I><a href="#getheight">getheight</a>()</I>
 <LI><I><a href="#getwidth">getwidth</a>()</I>
 <LI><I><a href="#strwidth">strwidth</a>(s)</I>
 <LI><I><a href="#charstr">charstr</a>(str)</I>
 <LI><I><a href="#translate">translate</a>(x, y, z)</I>
 <LI><I><a href="#scale">scale</a>(x, y, z)</I>
 <LI><I><a href="#rot">rot</a>(angle, axis)</I>
 <LI><I><a href="#rotate">rotate</a>(angle, axis)</I>
 <LI><I><a href="#patchbasis">patchbasis</a>(tbasisid, ubasisid)</I>
 <LI><I><a href="#patchprecision">patchprecision</a>(tseg, useg)</I>
 <LI><I><a href="#patchcurves">patchcurves</a>(nt, nu)</I>
 <LI><I><a href="#rpatch">rpatch</a>(gx, gy, gz, gw)</I>
 <LI><I><a href="#patch">patch</a>(gx, gy, gz)</I>
 <LI><I><a href="#pnt">pnt</a>(x, y, z)</I>
 <LI><I><a href="#pnt2">pnt2</a>(x, y)</I>
 <LI><I><a href="#makeobj">makeobj</a>(n)</I>
 <LI><I><a href="#closeobj">closeobj</a>()</I>
 <LI><I><a href="#genobj">genobj</a>()</I>
 <LI><I><a href="#getopenobj">getopenobj</a>()</I>
 <LI><I><a href="#callobj">callobj</a>(n)</I>
 <LI><I><a href="#isobj">isobj</a>(n)</I>
 <LI><I><a href="#delobj">delobj</a>(n)</I>
 <LI><I><a href="#gconfig">gconfig</a></I>
 <LI><I><a href="#doublebuffer">doublebuffer</a></I>
 <LI><I><a href="#singlebuffer">singlebuffer</a></I>
 <LI><I><a href="#backbuffer">backbuffer</a>(Boolean)</I>
 <LI><I><a href="#frontbuffer">frontbuffer</a>(Boolean)</I>
 <LI><I><a href="#swapbuffers">swapbuffers</a>()</I>
 <LI><I><a href="#getgpos">getgpos</a>(x, y, z, w)</I>
 <LI><I><a href="#getcpos">getcpos</a>(ix, iy)</I>
</UL>
</hr>


<a name=NAME>
<B>NAME</B>
 VOGL - A very ordinary GL Library.


<a name=DESC>
<B>DESCRIPTION</B>
 <I>VOGL  </I>is a library of C routines which try to allow a pro-
 grammer to write programs which can be moved  to  machines
 which  have the Silicon Graphics GL library on them. It is
 based entirely on the VOGLE graphics  library,  and  as  a
 result  can  handle  circles,  curves,  arcs, patches, and
 polygons in a device independent  fashion.  Simple  hidden
 line  removal  is  also  available via polygon backfacing.
 Access to hardware text and double buffering  of  drawings
 depends  on the driver.  There is also a FORTRAN interface
 but as it goes through the C routines  FORTRAN  users  are
 warned  that arrays are in row-column order in C. Both the
 long FORTRAN names and the shortened six  character  names
 are  supported.  People  interested in using software text
 should see the hershey library, <I>HERSHEY(3).</I>

 Some routines are only available in VOGL. If  you  include
 them  in  programs  it is advisable to put #ifdef VOGL ...
 #endif around them. The constant VOGL is defined  whenever
 a VOGL header file is included.

 It  should  be  noted  that there are a number of routines
 that take the type <I>Angle </I>for some of their parameters. All
 angles  specified  this way are actually <I>Integer Tenths Of</I>
 <I>Degrees.  </I>(Don't ask!)


<A name=include>
   <B>Include files.</B>
 There are two include files provided with vogl: vogl.h and
 vodevice.h.   The file vogl.h has the type definitions and
 function interfaces, ideally  it  is  included  where  you
 would  include gl.h on an SGI. The file vodevice.h has the
 devices in it, and it is included where you would  include
 device.h on an SGI.

<a name=summary>
   <B>The following is a brief summary of the VOGL subroutines.</B>
<a name=toolkits>
   <B>Using X toolkits ans Sunview</B>
 For  X11 and Sunview based applications, it is posible for
 VOGL to use a window that is  supplied  by  that  applica-
 tion's  toolkit. Under these circumstances, the toolkit is
 is responsible for handling of all input events, and  VOGL
 simply  draws  into the supplied  window.  These calls are
 only available from C.  Also  see  the  directories  exam-
 ples/xt, examples/xview and examples/sunview.

 For X based toolkits the following two calls may be used:

 <a name="voxtwindow">
  <I>vo_xt_window(display, xwin, width, height)</I>
  Tells VOGL to use the supplied window <I>xwin</I>

 vo_xt_window(display, xwin, width, height)
Display   *display;
Window    xwin;
int  width, height;

  This   routine  should  be  called  before  calling
  "<a href="#ginit">ginit</a>()".

	<a name="voxtwinsize">
 <I>vo_xt_win_size(width, height)</I>
  Tells VOGL that the  supplied  window  has  changed
  size.

 vo_xt_win_size(width, height)
int  width, height;



 For  sunview  based  applications  the following two calls
  may be used:

<a name="vosunviewcanvas">
 <I>vo_sunview_canvas(canvas, width, height)</I>
  Tells  VOGL to use the supplied sunview canvas <I>can-</I>
  <I>vas</I>


vo_sunview_canvas(canvas, width, height)
Canvas    canvas;
int  width, height;


  This  routine  should  be  called  before   calling
  "<a href="#ginit">ginit</a>()".


<a name=vosunviewcanvassize>
 <I>vo_sunview_canvas_size(width, height)</I>
  Tells  VOGL  that  the  supplied canvas has changed
  size.

 vo_sunview_canvas_size(width, height)
int  width, height;



<a name=devroutines>
   <B>Device routines.</B>
<a name=vinit>
 <I>vinit(device)</I>
  Tell VOGL what the device is. This routine needs to
  be called if the environment variable VDEVICE isn't
  set, or if the value in VDEVICE is not to be  used.

 Fortran:
subroutine vinit(device, len)
character *(*) device
integer len


 C:
vinit(device);
char     *device;

 Note 1 :- Current available devices are:
    tek - tektronix 4010 and compatibles
    hpgl - HP Graphics language and compatibles
    dxy - roland DXY plotter language
    postscript - postscript devices
    ppostscript - postscript devices (portrait mode)
    sun - Sun workstations running sunview
    X11 - X windows (SUN's Openwindows etc etc)
    decX11 - the decstation (old) window manager
    This is only included in case you need it.
    apollo - Apollo workstations
    NeXT   - NeXTStep
    hercules - IBM PC hercules graphics card
    cga - IBM PC cga graphics card
    ega - IBM PC ega graphics card
    vga - IBM PC vga graphics card
    sigma - IBM PC sigma graphics card.

    Sun, X11, decX11, apollo, hercules, cga
    and ega support double buffering.


 Note 2 :- If device is a NULL or a null string the value
of the environment variable "VDEVICE" is taken as the
device type to be opened.

 Note 3 :- after init it is wise to explicitly
clear the screen.

 e.g.: in C
color(BLACK);
clear();

 or    in Fortran
call color(BLACK)
call clear


<a name=ginit>
 <I>ginit()</I>
  Open the graphics device and do the basic initiali-
  sation. This routine is  marked  for  obsolescence.
  The  routine  <I><a href="#winopen">winopen</a>  </I>(see  below)  should be used
  instead.

 Fortran:
subroutine ginit

 C:
ginit()

<a name=winopen>
 <I>winopen(title)</I>
  Open the graphics device and do the basic initiali-
  sation.  This  routine  should  be  used instead of
  <I>ginit.</I>

 Fortran:
subroutine winopen(title, len)
character*(*) title
integer len

 C:
winopen(title)
     char *title;


<a name=gexit>
 <I>gexit()</I>
  Reset the window/terminal (must be  the  last  VOGL
  routine called)

 Fortran:
subroutine gexit

 C:
gexit()


<a name=voutput>
 <I>voutput(path)</I>
  Redirect  output from *next* ginit to file given by
  path. This routine only applies to devices  drivers
  that write to stdout e.g. postscript and hpgl.

 Fortran:
subroutine voutput(path, len)
character*(*) path
integer len

 C:
voutput(path)
     char *path;


<a name=newdev>
 <I>vnewdev(device)</I>
  Reinitialize  VOGL  to  use  a  new  device without
  changing attributes, viewport etc.  (eg. window and
  viewport specifications)

 Fortran:
subroutine vnewdev(device, len)
character *(*) device
integer len

 C:
vnewdev(device)
     char *device;

<a name=getplanes>
  <I>getplanes()  </I>Returns  the  number of bit planes (or
  color planes) for a particular device.  The  number
  of   colors  displayable  by  the  device  is  then
  2**(nplanes-1)

 Fortran:
integer function  getplanes()

 C:
long
getplanes()


<a name=flushing>
   <B>Routines for controling flushing or syncronisation of the dis-</B>
 <B>play.</B>
 On  some  devices (particularly X11) considerable speedups
 in display can be achieved by not flushing  each  graphics
 primitive call to the actual display until necessary. VOGL
 automatically delays flushing under in following cases:

- Within a callobj() call.
- Within curves and patches.
- Within bgn*/end* calls.
- When double buffering (the flush is only done withing swapbuffers).

 There are two user routines (which are NOT GL  compatible)
 that can be used to control flushing.

<a name=vsetflush>
 <I>vsetflush(yesno)</I>
  Set  global flushing status. If yesno = 0 (.false.)
  then  don't  do  any  flushing  (except  in   swap-
  buffers(),  or  <a href="#vflush">vflush</a>()).  If  yesno  = 1 (.true.)
  then do the flushing as described above.

 Fortran:
subroutine vsetflush(yesno)
logical yesno

 C:
void
vsetflush(yesno)
     int  yesno;

<a name=vflush>
 <I>vflush()</I>
  Call the device flush  or  syncronisation  routine.
  This forces a flush.

 Fortran:
subroutine vflush

 C:
void
vflush();


<a name=setup>
   <B>Routines For Setting Up Windows.</B>
 Some  devices  are basically window orientated - like sun-
 view and X11. You can give VOGL some information about the
 window  that  it  will use with these routines.  These can
 make your code very device dependent. Both  routines  take
 arguments  which are in device space. (0, 0) is the bottom
 left hand corner in device space. To have any effect these
 routines  must be called before ginit or winopen.  For the
 X11 device, an entry may be made in your  .Xdefaults  file
 of the form vogl.Geometry =150x500+550+50 (where you spec-
 ify your geometry as you please).

<a name=prefposition>
 <I>prefposition(x1, y1, x2, y2)</I>
  Specify the preferred position of the window opened
  by the *next* winopen.

 Fortran:
subroutine prefposition(x1, y1, x2, y2)
integer x1, y1, x2, y2

 C:
prefposition(x1, y1, x2, y2)
     long x1, y1, x2, y2


<a name=prefsize>
 <I>prefsize(width, height)</I>
  Specify  the preferred width and height of the win-
  dow opened by the *next* winopen.

 Fortran:
subroutine prefsize(width, height)
integer width, height

 C:
prefsize(width, height)
     long width, height;


<a name=reshapeviewport>
 <I>reshapeviewport</I>
  This is occasionally used in Iris GL  if  a  REDRAW
  event rolls up. While VOGL is unlikely to ever pro-
  vide a REDRAW event the call is provided  for  com-
  patibility.

 Fortran:
subroutine reshap

 C:
reshapeviewport()


<a name=general>
   <B>General Routines.</B>
<a name=clear>
 <I>clear()</I>
  Clears  the current viewport to the current colour.

 Fortran:
subroutine clear

 C:
clear()


<a name=color>
 <I>color(col)</I>
  Set the current colour. The standard colours are as
  follows:
 black = 0 red = 1   green = 2 yellow = 3
 blue = 4  magenta = 5     cyan = 6  white = 7.

 These are included in vogl.h as:

    BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN and WHITE.

 When using fortran these are included in fvogl.h as
    BLACK, RED, GREEN, YELLOW, BLUE, MAGENT, CYAN and WHITE.

 Fortran:
subroutine color(col)
integer col

 C:
color(col)
     Colorindex     col;


<a name=colorf>
 <I>colorf(col)</I>
  Same  as <I>color </I>only it takes a floating point argu-
  ment. In Iris GL there are sometimes  good  reasons
  for using this routine over <I>color.  </I>See the GL man-
  ual for more details.

 Fortran:
subroutine colorf(col)
real col

 C:
colorf(col)
     float     col;


<a name=mapcolor>
 <I>mapcolor(indx, red, green, blue)</I>
  Set the color map index indx to  the  color  repre-
  sented by (red, green, blue).  If the device has no
  color map this call does nothing.

 Fortran:
subroutine mapcolor(indx, red, green, blue)
integer indx, red, green, blue

 C:
mapcolor(indx, red, green, blue)
     Colorindex     indx;
     short    red, green, blue;


<a name=defbasis>
 <I>defbasis(id, mat)</I>
  Define basis number id to be the matrix mat.

 Fortran:
subroutine defbasis(id, mat)
integer id
real mat(4, 4)

 C:
defbasis(id, mat)
     short     id;
     Matrix    mat;


<a name=polymode>
 <I>polymode(mode)</I>
  <I>NOTE:- For this call to have  any  effect  </I>it  must
  have been <I>conditionally compilied </I>into the library.
  (See polygons.c for details) Control the filling of
  polygons. It expects one of the following PYM_LINE,
  which means only the edges of the polygon  will  be
  drawn  and  PYM_FILL  which  means fill the polygon
  (the default). PYM_POINT and  PYM_HOLLOW  are  also
  recognised  but  they  don't  behave  quite as they
  would with SGI GL.

  Also note that in Fortran  the  corresponding  con-
  stants  are truncated to PYM_LI, PYM_FI, PYM_PO and
  PYM_HO respectivly. These appear in fvogl.h.


 Fortran:
subroutine polymode(mode)
integer mode

 C:
polymode(mode)
     long mode;


<a name=queue>
   <B>The Device Queue and Valuator Routines.</B>
 The available devices are  defined  in  the  header  files
 vodevice.h and for FORTRAN fvodevice.h

<a name=qdevice>
 <I>qdevice(dev)</I>
  Enable  a  device.  Note:  in  VOGL the queue is of
  length 1.

 Fortran:
subroutine qdevice(dev)
integer dev

 C:
qdevice(dev)
     Device    dev;


<a name=unqdevice>
 <I>unqdevice(dev)</I>
  Disable a device.

 Fortran:
subroutine qdevice(dev)
integer dev

 C:
qdevice(dev)
     Device    dev;


<a name=qread>
 <I>qread(data)</I>
  Read an event from the device queue. This  routines
  blocks  until something happens. Note: it is impor-
  tant to have called qdevice before doing this.

 Fortran:
integer function qread(data)
integer*2 data

 C:
long qread(data)
     short     *data;


<a name=isqueued>
 <I>isqueued(dev)</I>
  Check to see if device dev is enabled for queueing.

 Fortran:
logical function isqueued(dev)
integer dev

 C:
Boolean isqueued(dev)
     short     *dev;


<a name=qtest>
 <I>qtest()</I>
  Check  if  there is anything in the queue. Note: in
  VOGL the queue is only 1 entry deep.

 Fortran:
logical function qtest

 C:
Boolean qtest()

<a name=qreset>
 <I>qreset()</I>
  Reset the device queue. This will get  rid  of  any
  pending events.

 Fortran:
subroutine qreset

 C:
qreset()


<a name=getbutton>
 <I>getbutton(dev)</I>
  Returns the up (0) or down (1) state of a button.

 Fortran:
logical function getbutton(dev)
integer dev

 C:
Boolean getbutton(dev)
     Device    dev;


<a name=getvaluator>
 <I>getvaluator(dev)</I>
  Return the current value of the valuator. Currently
  the only valuators supported are MOUSEX and MOUSEY.

 Fortran:
integer function getvaluator(dev)
integer dev

 C:
long getvaluator(dev)
     Device    dev;


<a name=vproutines>
   <B>Viewport Routines.</B>
<a name=viewport>
 <I>viewport(left, right, bottom, top)</I>
  Specify  which part of the screen to draw in. Left,
  right, bottom, and top are integer values in screen
  coordinates.

 Fortran:
subroutine viewport(left, right, bottom, top)
integer left, right, bottom, top

 C:
viewport(left, right, bottom, top)
     Screencoordleft, right, bottom, top;


<a name=pushviewport>
 <I>pushviewport()</I>
  Save current viewport on the viewport stack.

 Fortran:
subroutine pushviewport

 C:
pushviewport()


<a name=popviewport>
 <I>popviewport()</I>
  Retrieve last pushed viewport.

 Fortran:
subroutine popviewport

 C:
popviewport()


<a name=getviewport>
 <I>getviewport(left, right, bottom, top)</I>
  Returns  the  left, right, bottom and top limits of
  the current viewport in screen coordinates.

 Fortran:
subroutine getviewport(left, right, bottom, top)
integer*2 left, right, bottom, top

 C:
getviewport(left, right, bottom, top)
     Screencoord*left, *right, *bottom, *top;


<a name=stack>
   <B>Attribute Stack Routines.</B>
 The attribute  stack  contains  details  such  as  current
 color,  current line style and width, and the current font
 number. If you need to prevent object calls form  changing
 these,  use  <I>pushattributes  </I>before  the  call  and <I>popat-</I>
 <I>tributes </I>after.
<a name=pushattributes>
 <I>pushattributes()</I>
  Save the current attributes on the attribute stack.

 Fortran:
subroutine pushattributes

 C:
pushattributes()

<a name=popattributes>
 <I>popattributes()</I>
  Restore  the  attributes  to  what they were at the
  last <I>pushattribute().</I>

 Fortran:
subroutine popattributes

 C:
popattributes()


<a name=projection>
   <B>Projection Routines.</B>
 All the projection routines define  a  new  transformation
 matrix, and consequently the world units. Parallel projec-
 tions are defined by ortho or ortho2. Perspective  projec-
 tions  can be defined by perspective and window.  Note the
 types Angle, etc, are defined in vogl.h.  Remember  angles
 are in tenths of degrees.
<a name=ortho>
 <I>ortho(left, right, bottom, top, near, far)</I>
  Define  x  (left,  right),  y  (bottom, top), and z
  (near, far) clipping planes. The near and far clip-
  ping  planes  are  actually  specified as distances
  along the line of sight. These distances  can  also
  be  negative.   The actual location of the clipping
  planes is z = -near_d and z = -far_d.

 Fortran:
subroutine ortho(left, right, bottom, top, near_d, far_d)
real left, right, bottom, top, near_d, far_d

 C:
ortho(left, right, bottom, top, near_d, far_d)
     Coord     left, right, bottom, top, near_d, far_d;


<a name=ortho2>
 <I>ortho2(left, right, bottom, top)</I>
  Define x (left, right), and y (bottom,  top)  clip-
  ping planes.

 Fortran:
subroutine ortho2(left, right, bottom, top)
real left, right, bottom, top

 C:
ortho2(left, right, bottom, top)
     float     left, right, bottom, top;


<a name=perspective>
 <I>perspective(fov, aspect, near, far)</I>
  Specify  a  perspective  viewing  pyramid  in world
  coordinates by giving a field of view, aspect ratio
  and  the  distance from the eye of the near and far
  clipping plane.

 Fortran:
subroutine perspective(fov, aspect, near, far)
integer fov
real aspect, near, far

 C:
perspective(fov, aspect, near, far)
     Angle     fov;
     float     aspect;
     Coord     near, far;

<a name=window>
 <I>window(left, right, bot, top, near, far)</I>
  Specify a perspective viewing pyramid in world coordinates by
  giving the rectangle closest to the eye (ie. at the near clipping
  plane) and the distances to the near and far clipping planes.

 Fortran:
subroutine window(left, right, bot, top, near, far)
real left, right, bot, top, near, far

 C:
window(left, right, bot, top, near, far)
     float     left, right, bot, top, near, far;


<a name=matrix>
   <B>Matrix Stack Routines.</B>
<a name=pushmatrix>
 <I>pushmatrix()</I>
  Save  the  current  transformation  matrix  on  the
  matrix stack.

 Fortran:
subroutine pushmatrix

 C:
pushmatrix()


<a name=popmatrix>
 <I>popmatrix()</I>
  Retrieve  the  last  matrix  pushed and make it the
  current transformation matrix.

 Fortran:
subroutine popmatrix

 C:
popmatrix()


<a name=vpnrout>
   <B>Viewpoint Routines.</B>
 Viewpoint routines alter the current tranformation matrix.

<a name=polarview>
 <I>polarview(dist, azim, inc, twist)</I>
  Specify  the viewer's position in polar coordinates
  by giving the distance from the  viewpoint  to  the
  world origin, the azimuthal angle in the x-y plane,
  measured from the y-axis, the  incidence  angle  in
  the  y-z  plane,  measured from the z-axis, and the
  twist angle about the line of sight.

 Fortran:
subroutine polarview(dist, azim, inc, twist)
real dist
integer azim, inc, twist

 C:
polarview(dist, azim, inc, twist)
     Coord     dist;
     Angle     azim, inc, twist;


<a name=lookat>
 <I>lookat(vx, vy, vz, px, py, pz, twist)</I>
  Specify the viewer's position by giving a viewpoint
  and a reference point in world coordinates. A twist
  about the line of sight may also be given.

 Fortran:
subroutine lookat(vx, vy, vz, px, py, pz, twist)
real vx, vy, vz, px, py, pz
integer twist

 C:
lookat(vx, vy, vz, px, py, pz, twist)
     float     vx, vy, vz, px, py, pz;
     Angle     twist;


<a name=movrout>
   <B>Move Routines.</B>
 There are variations on all these routines that end in 's'
 and  also  end  in  'i'. In the case of the 's' variations
 they take arguments of type Scoord in C and  integer*2  in
 FORTRAN. In the case of the 'i' variations they take argu-
 ments of type Icoord in C and integer in FORTRAN.

<a name=move>
 <I>move(x, y, z)</I>
  Move current graphics position to (x, y, z). (x, y,
  z) is a point in world coordinates.

 Fortran:
subroutine move(x, y, z)
real x, y, z

 C:
move(x, y, z)
     Coord     x, y, z;


<a name=rmv>
 <I>rmv(deltax, deltay, deltaz)</I>
  Relative  move. deltax, deltay, and deltaz are off-
  sets in world units.

 Fortran:
subroutine rmv(deltax, deltay, deltaz)
real deltax, deltay, deltaz

 C:
rmv(deltax, deltay, deltaz)
     Coord   deltax, deltay, deltaz;


<a name=move2>
 <I>move2(x, y)</I>
  Move graphics position to point (x, y). (x, y) is a
  point in world coordinates.

 Fortran:
subroutine move2(x, y)
real x, y

 C:
move2(x, y)
     Coord     x, y;


<a name=rmv2>
 <I>rmv2(deltax, deltay)</I>
  Relative  move2.  deltax  and deltay are offsets in
  world units.

 Fortran:
subroutine rmv2(deltax, deltay)
real deltax, deltay

 C:
rmv2(deltax, deltay)
     Coord     deltax, deltay;



<a name=Line>
   <B>Line routines.</B>
 These  routines set the line style and line width  if  the
 current device is capable of doing so.

<a name=deflinestyle>
 <I>deflinestyle(n, style)</I>
  Define  a line style and binds it to the integer n.
  The  line style is a bit pattern of 16 bits  width.
 Fortran:
subroutine deflin(n, style)
integer   n
integer style

 C:
deflinestyle(n, style)
     short     n;
     Linestyle style;



<a name=setlinestyle>
 <I>setlinestyle(n)</I>
  Sets the current line style.
 Fortran:
subroutine setlin(n)
integer   n

 C:
setlinestyle(n)
     short     n;



<a name=linewidth>
 <I>linewidth(n)</I>
  Sets the current line width to 'n' pixels wide.
 Fortran:
subroutine linewi(n)
integer   n

 C:
linewidth(n)
     short     n;




<a name=Drawing>
   <B>Drawing Routines.</B>
 There are variations on all these routines that end in 's'
 and also end in 'i'. In the case  of  the  's'  variations
 they  take  arguments of type Scoord in C and integer*2 in
 FORTRAN. In the case of the 'i' variations they take argu-
 ments of type Icoord in C and integer in FORTRAN.

<a name=draw>
 <I>draw(x, y, z)</I>
  Draw  from  current graphics position to (x, y, z).
  (x, y, z) is a point in world coordinates.

 Fortran:
subroutine draw(x, y, z)
real x, y, z

 C:
draw(x, y, z)
     Coord     x, y, z;


<a name=rdr>
 <I>rdr(deltax, deltay, deltaz)</I>
  Relative draw. deltax, deltay, and deltaz are  off-
  sets in world units.

 Fortran:
subroutine rdr(deltax, deltay, deltaz)
real deltax, deltay, deltaz

 C:
rdr(deltax, deltay, deltaz)
     Coord   deltax, deltay, deltaz;


<a name=draw2>
 <I>draw2(x, y)</I>
  Draw  from  current  graphics position to point (x,
  y). (x, y) is a point in world coordinates.

 Fortran:
subroutine draw2(x, y)
real x, y

 C:
draw2(x, y)
     Coord     x, y;


<a name=rdr2>
 <I>rdr2(deltax, deltay)</I>
  Relative draw2. deltax and deltay  are  offsets  in
  world units.

 Fortran:
subroutine rdr2(deltax, deltay)
real deltax, deltay

 C:
rdr2(deltax, deltay)
     Coord   deltax, deltay;



<a name=Vertex>
   <B>Vertex calls.</B>
 There  are calls which we term 'vertex calls' which simply
 specify a point in 4D, 3D or 2D. These calls take an array
 which  specifies  the coordinates of the point. The inter-
 pretation of these points is described below.

<a name=v4d>
 <I>v4d(v) </I>Specify a vertex(point) in 4D using  double  preci-
 sion numbers.

Fortran:
     subroutine v4d(v)
     real *8 v(4)

C:
     v4d(v)
    double v[4];


<a name=v4f>
 <I>v4f(v)  </I>Specify  a vertex(point) in 4D using single preci-
 sion floating point numbers.

Fortran:
     subroutine v4f(v)
     real v(4)

C:
     v4f(v)
    float v[4];


<a name=v4i>
 <I>v4i(v) </I>Specify a vertex(point) in 4D using integer numbers

Fortran:
     subroutine v4i(v)
     integer v(4)

C:
     v4i(v)
    long v[4];


<a name=v4s>
 <I>v4s(v)  </I>Specify  a vertex(point) in 4D using short integer
 numbers

Fortran:
     subroutine v4s(v)
     integer *2  v(4)

C:
     v4s(v)
    short v[4];




 There are also equivalent calls for 3D points  (v3d,  v3f,
 v3i,  v3s)  and  2D  points (v2d, v2f, v2i, v2s). The only
 difference is the number  of  elements  that  each  vertex
 needs  to  be  specified.  It should also be noted the the
 different data types (ie. double, float, long  and  short)
 are  merely  different ways of representing the same basic
 coordinate data (calling v3s with v[] =  {100,200,200}  is
 the same as calling v3f with v[] = {100.0, 200.0, 200.0}).

 The way these points are interpreted depends on what  mode
 has  be  set  up  with one of the calls <I>bgnpoint, bgnline,</I>
 <I>bgnclosedline or bgnpolygon.  </I>The <I>bgnpoint </I>call  specifies
 that  the  next  series  of  vertex calls are specifying a
 chain of points (dots) to be drawn. A <I>bgnpoint  </I>is  termi-
 nated with a <I>endpoint </I>call.

Fortran:
     subroutine bgnpoint

C:
     bgnpoint()

Fortran:
     subroutine endpoint

C:
     endpoint()



 The  <I>bgnline </I>call specifies that the next series of vertex
 calls are specifying the points on a polyline. A <I>bgnline</I>
  is terminated with a <I>endline </I>call.

Fortran:
     subroutine bgnline

C:
     bgnline()

Fortran:
     subroutine endline

C:
     endline()



 The <I>bgnclosedline </I>call is similar to  the  <I>bgnline  </I>except
 that  when  <I>endclosedline  </I>is called the first point given
 (ie. the one first after the bgnclosedline call) is joined
 to  the last point given (ie. the one just before the end-
 closedline call).

Fortran:
     subroutine bgncloseline

C:
     bgnclosedline()

Fortran:
     subroutine endclosedline

C:
     endclosedline()



 The <I>bgnpolygon </I>call specifies that the next series of ver-
 tex  calls  are  defining  a  polygon.  When <I>endpolygon </I>is
 called, the polygon is closed and filled (or drawn  as  an
 outline  depending  on the mode that has been set with the
 <I>polymode </I>call if this call has  been  compilied  into  the
 library.


Fortran:
     subroutine bgnpolygon

C:
     bgnpolygon()

Fortran:
     subroutine endpolygon

C:
     endpolygon()




<a name=Arcs>
   <B>Arcs and Circles.</B>
 There are variations on all these routines that end in 's'
 and also end in 'i'. In the case  of  the  's'  variations
 they  take  arguments of type Scoord in C and integer*2 in
 FORTRAN. In the case of the 'i' variations they take argu-
 ments of type Icoord in C and integer in FORTRAN.

<a name=circleprecision>
 <I>circleprecision(nsegs)</I>
  Set the number of line segments making up a circle.
  Default is currently 32. The number of segments  in
  an  arc is calculated from nsegs according the span
  of the arc.  This  routine  is  only  available  in
  VOGL.
 Fortran:
subroutine circleprecision(nsegs)
integer   nsegs
 C:
circleprecision(nsegs)
     int  nsegs;


<a name=arc>
 <I>arc(x, y, radius, startang, endang)</I>
  Draw  an  arc. x, y, and radius are values in world
  units.

 Fortran:
subroutine arc(x, y, radius, startang, endang)
real x, y, radius;
integer startang, endang;
 C:
arc(x, y, radius, startang, endang)
     Coord  x, y, radius;
     Angle  startang, endang;


<a name=arcf>
 <I>arcf(x, y, radius, startang, endang)</I>
  Draw a filled arc. x, y, and radius are  values  in
  world  units.  (How  the  filling  is  done  may be
  changed by calling <I>polymode </I>, if this call has been
  compilied into the library).

 Fortran:
subroutine arcf(x, y, radius, startang, endang)
real x, y, radius;
integer startang, endang;
 C:
arcf(x, y, radius, startang, endang)
     Coord  x, y, radius;
     Angle  startang, endang;


<a name=circ>
 <I>circ(x, y, radius)</I>
  Draw a circle. x, y, and radius are values in world
  units.

 Fortran:
subroutine circ(x, y, radius)
real x, y, radius
 C:
circ(x, y, radius)
     Coord     x, y, radius;


<a name=circf>
 <I>circf(x, y, radius)</I>
  Draw a filled circle. x, y, and radius  are  values
  in  world  units.   How  the filling is done may be
  changed by calling <I>polymode.</I>

 Fortran:
subroutine circf(x, y, radius)
real x, y, radius
 C:
circf(x, y, radius)
     Coord     x, y, radius;


<a name=Curve>
   <B>Curve Routines.</B>
<a name=curvebasis>
 <I>curvebasis(id)</I>
  Set the basis matrix for a curve to the matrix ref-
  erenced  by  id.   The  matrix and it's id are tied
  together with a call to <I>defbasis.</I>

 Fortran:
subroutine curvebasis(id)
integer id
 C:
curvebasis(id)
     short     id;


<a name=curveprecision>
 <I>curveprecision(nsegs)</I>
  Define the number of line segments used to  draw  a
  curve.

 Fortran:
subroutine curveprecision(nsegs)
integer nsegs
 C:
curveprecision(nsegs)
     short     nsegs;


<a name=rcrv>
 <I>rcrv(geom)</I>
  Draw a rational curve.

 Fortran:
subroutine rcrv(geom)
real geom(4,4)
 C:
rcrv(geom)
     Coord     geom[4][4];


<a name=rcrvn>
 <I>rcrvn(n, geom)</I>
  Draw n - 3 rational curve segments. Note: n must be
  at least 4.

 Fortran:
subroutine rcrvn(n, geom)
integer n
real geom(4,n)
 C:
rcrvn(n, geom)
     long n;
     Coord     geom[][4];


<a name=crv>
 <I>crv(geom)</I>
  Draw a curve.

 Fortran:
subroutine crv(geom)
real geom(3,4)
 C:
crv(geom)
     Coord     geom[4][3];


<a name=crvn>
 <I>crvn(n, geom)</I>
  Draw n - 3 curve segments. Note: n must be at least
  4.

 Fortran:
subroutine crvn(n, geom)
integer n
real geom(3,n)
 C:
crvn(n, geom)
     long n;
     Coord     geom[][3];

<a name=curveit>
 <I>curveit(n)</I>
  Draw a curve segment by iterating the top matrix in
  the matrix stack as a  forward  difference  matrix.
  This performs 'n' iterations.

 Fortran:
subroutine curveit(n)
integer n

 C:
curveit(n)
     short     n;


<a name=Rect>
   <B>Rectangles and General Polygon Routines.</B>
 See  also  <I>Vertex  </I>calls  above.   The way in which filled
 polygons (including circles and arcs) are treated  depends
 on the mode that has been set with the <I>polymode </I>call.

 There are variations on all these routines that end in 's'
 and also end in 'i'. In the case  of  the  's'  variations
 they  take  arguments of type Scoord in C and integer*2 in
 FORTRAN. In the case of the 'i' variations they take argu-
 ments of type Icoord in C and integer in FORTRAN.

<a name=rect>
 <I>rect(x1, y1, x2, y2)</I>
  Draw a rectangle.

 Fortran:
subroutine rect(x1, y1, x2, y2)
real x1, y1, x1, y2
 C:
rect(x1, y1, x2, y2)
     Coord     x1, y1, x2, y2;


<a name=rectf>
 <I>rectf(x1, y1, x2, y2)</I>
  Draw  a  filled rectangle. (How the filling is done
  may be changed by calling <I>polymode </I>, if  this  call
  has been compilied into the library).

 Fortran:
subroutine rectf(x1, y1, x2, y2)
real x1, y1, x1, y2
 C:
rectf(x1, y1, x2, y2)
     Coord     x1, y1, x2, y2;


<a name=poly2>
 <I>poly2(n, points)</I>
  Construct  a (x, y) polygon from an array of points
  provided by the user.

 Fortran:
subroutine poly2(n, points)
integer n
real points(2, n)
 C:
poly2(n, points)
     long n;
     Coord     points[][2];


<a name=polf2>
 <I>polf2(n, points)</I>
  Construct a filled (x, y) polygon from an array  of
  points  provided  by the user.  (How the filling is
  done may be changed by calling <I>polymode </I>,  if  this
  call has been compilied into the library).

 Fortran:
subroutine polf2(n, points)
integer n
real points(2, n)
 C:
polf2(n,  points)
     long n;
     Coord     points[][2];


<a name=poly>
 <I>poly(n, points)</I>
  Construct  a  polygon  from an array of points pro-
  vided by the user.

 Fortran:
subroutine poly(n, points)
integer n
real points(3, n)
 C:
poly(n,  points)
     long n;
     float     points[][3];


<a name=polf>
 <I>polf(n, points)</I>
  Construct a filled polygon from an array of  points
  provided by the user.  (How the filling is done may
  be changed by calling <I>polymode </I>, if this  call  has
  been compilied into the library).

 Fortran:
subroutine polf(n, points)
integer n
real points(3, n)
 C:
polf(n, points)
     long n;
     Coord     points[][3];

<a name=backface>
 <I>backface(onoff)</I>
  Turns  on culling of backfacing polygons. A polygon
  is  backfacing  if  it's  orientation  in  *screen*
  coords is clockwise.

 Fortran:
subroutine backface(onoff)
logical onoff

 C:
backface(onoff)
     Boolean   onoff;


<a name=frontface>
 <I>frontface(onoff)</I>
  Turns on culling of frontfacing polygons. A polygon
  is frontfacing  if  it's  orientation  in  *screen*
  coords is anticlockwise.

 Fortran:
subroutine frontface(clockwise)
logical onoff

 C:
frontface(clockwise)
     Boolean   onoff;


<a name=Text>
   <B>Text routines.</B>
 The original VOGLE hardware fonts "small" and "large" have
 the font numbers 0 and 1 respectively. The default font is
 0.  For X11 displays the default fonts used by the program
 can be overridden by placing the following defaults in the
 ~/.Xdefaults file:
vogl.smallfont: &ltfont name&gt
vogl.largefont: &ltfont name&gt

<a name=font>
 <I>font(fontid)</I>
  Set the current font

 Fortran:
subroutine font(fontid)
integer fontid;

 C:
font(fontid)
     short     fontid;


<a name=cmov>
 <I>cmov(x, y, z)</I>
  Change  the  current  character position. The usual
  variations with the extensions  'i'  and  's'  also
  apply here.

 Fortran:
subroutine cmov(x, y, z)
real x, y, z;

 C:
cmov(x, y, z)
     Coord     x, y, z;


<a name=cmov2>
 <I>cmov2(x, y)</I>
  Change  the  current character position in x and y.
  The usual variations with the  extensions  'i'  and
  's' also apply here.

 Fortran:
subroutine cmov2(x, y)
real x, y;

 C:
cmov2(x, y)
     Coord     x, y;


<a name=getheight>
 <I>getheight()</I>
  Return the maximum height in the current font.

 Fortran:
integer function getheight

 C:
long
getheight()


<a name=getwidth>
 <I>getwidth()</I>
  Return the maximum width in the current font.

 Fortran:
integer function getwidth

 C:
long
getwidth()


<a name=strwidth>
 <I>strwidth(s)</I>
  Return the length of the string s in screen coords.

 Fortran:
integer function strwidth(s, n)
     character *(*) s
     integer   n;

 C:
long
strwidth(s)
     char *s;



<a name=charstr>
 <I>charstr(str)</I>
  Draw the text in string at the current position.

 Fortran:
subroutine charst(str, len)
character*(*) str
integer len

 C:
charstr(str)
     char *str;


<a name=Transf>
   <B>Transformations Routines.</B>
 All transformations are cumulative, so if you rotate some-
 thing and then do a translate you are translating relative
 to the rotated axes. If you need to preserve  the  current
 transformation  matrix  use  pushmatrix(), do the drawing,
 and then call popmatrix()  to  get  back  where  you  were
 before.
<a name=translate>
 <I>translate(x, y, z)</I>
  Set up a translation.

 Fortran:
subroutine translate(x, y, z)
real x, y, z
 C:
translate(x, y, z)
     Coord     x, y, z;


<a name=scale>
 <I>scale(x, y, z)</I>
  Set up scaling factors in x, y, and z axis.

 Fortran:
subroutine scale(x, y, z)
real x, y, z

 C:
scale(x, y, z)
     Coord     x, y, z;


<a name=rot>
 <I>rot(angle, axis)</I>
  Set up a rotation in axis axis. Axis is one of 'x',
  'y', or 'z'.  The angle in this case is a real num-
  ber in degrees.

 Fortran:
subroutine rot(angle, axis)
real angle
character axis

 C:
rot(angle, axis)
     float     angle;
     char axis;


<a name=rotate>
 <I>rotate(angle, axis)</I>
  Set up a rotation in axis axis. Axis is one of 'x',
  'y', or 'z', and the angle is in tenths of degrees.
  Makes you feel sentimental doesn't it.

 Fortran:
subroutine rotate(angle, axis)
integer angle
character axis

 C:
rotate(angle, axis)
     Angle     angle;
     char axis;


<a name=Patch>
   <B>Patch Routines.</B>
<a name=patchbasis>
 <I>patchbasis(tbasisid, ubasisid)</I>
  Define the t and u basis matrix id's of a patch. It
  is assumed that tbasisid and ubasisid have matrices
  associated  with  them  already (this is done using
  the <I>defbasis </I>call).

 Fortran:
subroutine patchbasis(tid, uid)
integer tid, uid

 C:
patchbasis(tid, ubid)
     long tid, uid


<a name=patchprecision>
 <I>patchprecision(tseg, useg)</I>
  Set the minimum number of line segments  making  up
  curves in a patch.

 Fortran:
subroutine patchprecision(tseg, useg)
integer tseg, useg

 C:
patchprecision(tseg, useg)
     long     tseg, useg;


<a name=patchcurves>
 <I>patchcurves(nt, nu)</I>
  Set the number of curves making up a patch.

 Fortran:
subroutine patchcurves(nt, nu)
integer nt, nu

 C:
patchcurves(nt, nu)
     long     nt, nu;


<a name=rpatch>
 <I>rpatch(gx, gy, gz, gw)</I>
  Draws  a  rational  patch  in  the  current  basis,
  according to the geometry matrices gx, gy, gz,  and
  gw.

 Fortran:
subroutine rpatch(gx, gy, gz, gw)
real  gx(4,4), gy(4,4), gz(4,4), gw(4,4)

 C:
rpatch(gx, gy, gz, gw)
    Matrix  gx, gy, gz, gw;

<a name=patch>
 <I>patch(gx, gy, gz)</I>
  Draws  a  patch  in the current basis, according to
  the geometry matrices gx, gy, and gz.

 Fortran:
subroutine patch(gx, gy, gz)
real  gx(4,4), gy(4,4), gz(4,4)

 C:
patch(gx, gy, gz)
     Matrix  gx, gy, gz;


<a name=Point>
   <B>Point Routines.</B>
 There are variations on all these routines that end in 's'
 and  also  end  in  'i'. In the case of the 's' variations
 they take arguments of type Scoord in C and  integer*2  in
 FORTRAN. In the case of the 'i' variations they take argu-
 ments of type Icoord in C and integer in FORTRAN.

<a name=pnt>
 <I>pnt(x, y, z)</I>
  Draw a point at x, y, z

 Fortran:
subroutine pnt(x, y, z)
real x, y, z

 C:
pnt(x, y, z)
     Coord     x, y, z;

<a name=pnt2>
 <I>pnt2(x, y)</I>
  Draw a point at x, y.

 Fortran:
subroutine pnt2(x, y)
real x, y

 C:
pnt2(x, y)
     Coord     x, y;


<a name=Obj>
   <B>Object Routines.</B>
 Objects are graphical entities created by the drawing rou-
 tines called between <I>makeobj </I>and <I>closeobj.  </I>Objects may be
 called from within other objects. When an object  is  cre-
 ated most of the calculations required by the drawing rou-
 tines called within it are done up to where  the  calcula-
 tions involve the current transformation matrix. So if you
 need to draw the same thing several times  on  the  screen
 but  in  different places it is faster to use objects than
 to call the appropriate drawing routines each time.

<a name=makeobj>
 <I>makeobj(n)</I>
  Commence the object number n.

 Fortran:
subroutine makeobj(n)
integer n

 C:
makeobj(n)
     Object    n;


<a name=closeobj>
 <I>closeobj()</I>
  Close the current object.

 Fortran:
subroutine closeobj()

 C:
closeobj()


<a name=genobj>
 <I>genobj()</I>
  Returns a unique object identifier.

 Fortran:
integer function genobj()
 C:
Object
genobj()


<a name=getopenobj>
 <I>getopenobj()</I>
  Return the number of the current object.

 Fortran:
integer function getopenobj()

 C:
Object
getopenobj()


<a name=callobj>
 <I>callobj(n)</I>
  Draw object number n.

 Fortran:
subroutine callobj(n)
integer n

 C:
callobj(n)
     Object    n;


<a name=isobj>
 <I>isobj(n)</I>
  Returns non-zero if there is an object of number n.

 Fortran:
logical function isobj(n)
integer n

 C:
Boolean
isobj(n)
     Object    n;


<a name=delobj>
 <I>delobj(n)</I>
  Delete the object number n.

 Fortran:
subroutine delobj(n)
integer n

 C:
delobj(n)
     Object    n;


<a name=Buff>
   <B>Double Buffering.</B>
 Where  possible  VOGL allows for front and back buffers to
 enable things like animation and smooth  updating  of  the
 screen.  Note:  it  isn't  possible to have backbuffer and
 frontbuffer true at the same time.

<a name=gconfig>
 <I>gconfig</I>
  With Iris GL you must call gconfig for things  like
  doublebuffering to take effect.

 Fortran:
subroutine gconfig

 C:
gconfig()


<a name=doublebuffer>
 <I>doublebuffer</I>
  Flags our intention to do double buffering.

 Fortran:
subroutine doublebuffer

 C:
doublebuffer()


<a name=singlebuffer>
 <I>singlebuffer</I>
  Switch back to singlebuffer mode.

 Fortran:
subroutine singlebuffer

 C:
singlebuffer()


<a name=backbuffer>
 <I>backbuffer(Boolean)</I>
  Make VOGL draw in the backbuffer.

 Fortran:
subroutine backbuffer(yesno)
     logical   yesno;

 C:
backbuffer(yesno)
     Boolean   yesno;


<a name=frontbuffer>
 <I>frontbuffer(Boolean)</I>
  Make VOGL draw in the front buffer.

 Fortran:
subroutine frontbuffer(yesno)
     logical   yesno;

 C:
frontbuffer(yesno)
     Boolean   yesno;


<a name=swapbuffers>
 <I>swapbuffers()</I>
  Swap the front and back buffers.

 Fortran:
subroutine swapbuffers

 C:
swapbuffers()


<a name=Pos>
   <B>Position Routines.</B>
<a name=getgpos>
 <I>getgpos(x, y, z, w)</I>
  Gets the current graphics position in world coords.

 Fortran:
subroutine getgpos(x, y, z, w)
real x, y, z

 C:
getgpos(x, y, z, w)
     Coord *x, *y, *z, *w;


<a name=getcpos>
 <I>getcpos(ix, iy)</I>
  Gets  the  current  character  position  in  screen
  coords.

 Fortran:
subroutine getcpo(ix, iy)
integer ix, iy

 C:
getcpos(ix, iy)
     Scoord *ix, *iy;


<a name=Bugs>
<B>BUGS</B>
 Double buffering isn't supported on all devices.

 The  yobbarays may be turned on or they may be turned off.










VOGL 1.2 22 Apr 1992 33


</PRE></BODY>
